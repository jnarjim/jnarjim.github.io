{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"Actividades%20Ciclo%20de%20vida%20del%20sofware%20y%20Kanban-Scrum/","text":"Actividades: Ciclo de vida del software 1. Define \"Ciclo de vida del software\" El ciclo de vida del desarrollo de software es la estructura que contiene los procesos, actividades y tareas relacionadas con el desarrollo y mantenimiento de un producto de software, abarcando la vida completa del sistema, desde la definici\u00f3n de los requisitos hasta la finalizaci\u00f3n de su uso. 2) Nombra las fases principales del desarrollo de software y explica brevemente qu\u00e9 se hace en cada una de ellas. Planificaci\u00f3n: Antes de iniciar un proyecto de desarrollo de un sistema de informaci\u00f3n, es necesario hacer ciertas tareas que influir\u00e1n decisivamente en el \u00e9xito del mismo. Dichas tareas no est\u00e1n sujetas a plazos. Algunas de las tareas incluyen actividades como la determinaci\u00f3n del \u00e1mbito del proyecto, la realizaci\u00f3n de un estudio de viabilidad, el an\u00e1lisis de los riesgos asociados, la estimaci\u00f3n del coste del proyecto, su planificaci\u00f3n temporal y la asignaci\u00f3n de recursos a las diferentes etapas del proyecto. An\u00e1lisis: Hay que averiguar qu\u00e9 es exactamente lo que tiene que hacer el software. Esta etapa corresponde al proceso a trav\u00e9s del cual se intenta descubrir qu\u00e9 es lo que realmente se necesita y se llega a una comprensi\u00f3n adecuada de los requerimientos del sistema (las caracter\u00edsticas que el sistema debe poseer). Dise\u00f1o: En esta fase se estudian posibles opciones de implementaci\u00f3n para el software que hay que construir, as\u00ed como decidir la estructura general del mismo. El dise\u00f1o es una etapa compleja y su proceso debe realizarse de manera iterativa. Implementaci\u00f3n: En esta fase hay que elegir las herramientas adecuadas, un entorno de desarrollo que facilite el trabajo y un lenguaje de programaci\u00f3n apropiado para el tipo de software a construir. Esta elecci\u00f3n depender\u00e1 tanto de las decisiones de dise\u00f1o tomadas como del entorno en el que el software deba funcionar. Pruebas: La fase de pruebas busca detectar los fallos cometidos en las etapas anteriores para corregirlos. Por supuesto, lo ideal es hacerlo antes de que el usuario final se los encuentre. Se dice que una prueba es un \u00e9xito si se detecta alg\u00fan error. Instalaci\u00f3n: La siguiente fase es poner el software en funcionamiento, por lo que hay que planificar el entorno teniendo en cuenta las dependencias existentes entre los diferentes componentes del mismo. Uso y mantenimiento: Esta es una de las fases m\u00e1s importantes del ciclo de vida de desarrollo del software. Puesto que el software ni se rompe ni se desgasta con el uso, su mantenimiento incluye tres puntos diferenciados: -Eliminar los defectos detectados durante su vida \u00fatil (mantenimiento correctivo). -Adaptarlo a nuevas necesidades (mantenimiento adaptativo). -A\u00f1adirle nuevas funcionalidades (mantenimiento perfectivo). 3) Explica brevemente en qu\u00e9 consiste el modelo en cascada cuando hablamos de desarrollo de software. El desarrollo en cascada es un procedimiento lineal que se caracteriza por dividir los procesos de desarrollo en sucesivas fases de proyecto. Al contrario que en los modelos iterativos, cada una de estas fases se ejecuta tan solo una vez. Los resultados de cada una de las fases sirven como hip\u00f3tesis de partida para la siguiente. Este procedimiento se utiliza, especialmente, en el desarrollo de software. 4) Ventajas e inconvenientes del modelo en cascada. Ventajas: -Una estructura sencilla gracias a unas fases de proyecto claramente diferenciadas. -Buena documentaci\u00f3n del proceso de desarrollo a trav\u00e9s de unos hitos bien definidos. -Los costes y la carga de trabajo se pueden estimar al comenzar el proyecto. -Aquellos proyectos que se estructuran en base al modelo en cascada se pueden representar cronol\u00f3gicamente de forma sencilla. Inconvenientes: -Por norma general, los proyectos m\u00e1s complejos o de varios niveles no permiten su divisi\u00f3n en fases de proyecto claramente diferenciadas. -Poco margen para realizar ajustes a lo largo del proyecto debido a un cambio en las exigencias. -El usuario final no se integra en el proceso de producci\u00f3n hasta que no termina la programaci\u00f3n. -En ocasiones, los fallos solo se detectan una vez finalizado el proceso de desarrollo. 5) \u00bfQu\u00e9 se entiende por verificaci\u00f3n? \u00bfY por validaci\u00f3n? -La verificaci\u00f3n de software es una disciplina de la ingenier\u00eda de software cuyo objetivo es asegurar que el software satisface por completo todos los requisitos esperados. -La validaci\u00f3n de software es un proceso que demuestra a partir de documentos que el sistema cumple con las funciones de las cuales fue designado, de acuerdo con las especificaciones de los requisitos del usuario y con la garant\u00eda de seguridad y trazabilidad de informaciones. 6) Explica c\u00f3mo funciona el modelo de desarrollo mediante creaci\u00f3n de prototipos. Un modelo prototipo o modelo de desarrollo evolutivo es utilizado principalmente en el desarrollo de software para ofrecer al usuario una visi\u00f3n previa de c\u00f3mo ser\u00e1 el programa o sistema. Se le dice de desarrollo evolutivo al modelo de prototipo porque evoluciona hasta convertirse en el producto final.El modelo de prototipos se centra en un dise\u00f1o r\u00e1pido que representa las caracter\u00edsticas principales del programa que el usuario podr\u00e1 ver o utilizar. De esta manera pueden probarlo y dar su opini\u00f3n sobre distintos aspectos como la usabilidad, la utilidad o el rendimiento, entre otras.El prototipo se puede modificar cuando sea necesario y todos los resultados obtenidos de las presentaciones y pruebas se deben anotar para utilizar posteriormente como ayuda en el desarrollo del producto final. ## Actividades: Kanban y Scrum 1) Haz un resumen de la metodolog\u00eda Kanban e indica sus diferencias frente a SCRUM. Kanban es una forma de ayudar a los equipos a encontrar un equilibrio entre el trabajo que necesitan hacer y la disponibilidad de cada miembro del equipo. La metodolog\u00eda Kanban se basa en una filosof\u00eda centrada en la mejora continua, donde las tareas se \u201cextraen\u201d de una lista de acciones pendientes en un flujo de trabajo constante. La metodolog\u00eda Kanban se implementa por medio de tableros Kanban. Se trata de un m\u00e9todo visual de gesti\u00f3n de proyectos que permite a los equipos visualizar sus flujos de trabajo y la carga de trabajo. En un tablero Kanban, el trabajo se muestra en un proyecto en forma de tablero organizado por columnas. Tradicionalmente, cada columna representa una etapa del trabajo. Scrum es m\u00e1s estricto que Kanban. Este marco incluye un conjunto espec\u00edfico de reglas que los equipos deben seguir, mientras que Kanban se usa m\u00e1s para visualizar el trabajo. Muchos equipos implementan Scrum en un tablero Kanban, pero en esos casos, la metodolog\u00eda sigue siendo Scrum, no Kanban. Esta \u00faltima, m\u00e1s que una metodolog\u00eda estricta, es una forma de visualizar el trabajo. Scrum tiene un l\u00edmite de tiempo, Kanban es flexible. Scrum se ejecuta en sprints, que suelen ser ciclos de trabajo de dos semanas. Al final de un sprint, tienes un conjunto de tareas terminadas, sin importar cu\u00e1les sean. Los tableros Kanban no necesariamente tienen una fecha de inicio o finalizaci\u00f3n. De hecho a menudo se usan tableros Kanban para visualizar procesos en curso. Las columnas del tablero Kanban se pueden organizar de diferentes formas. Cuando implementas un Scrum, es importante realizar un seguimiento del trabajo a medida que avanzas por las diferentes etapas. Sin embargo, en un tablero Kanban que no se basa en Scrum, las columnas pueden representar diferentes aspectos, no solo el estado; como, por ejemplo, el trabajo que se realizar\u00e1 cada mes, una retrospectiva que identifica las tareas que se completaron anteriormente, o cualquier otra cosa que necesites. En esto se diferencia de las reglas m\u00e1s definidas de Scrum. 2) Explica c\u00f3mo funciona SCRUM . Planificaci\u00f3n del sprint: Estos suelen durar dos semanas, aunque los equipos pueden realizar sprints m\u00e1s r\u00e1pidos o breves. Durante esta etapa, el Scrum Master y el equipo analizan el trabajo pendiente y determinan qu\u00e9 tareas realizar durante el Sprint. Reuniones diarias de actualizaci\u00f3n: Durante el transcurso del Scrum (tambi\u00e9n conocido como el \u201cciclo\u201d de Scrum), los equipos suelen reunirse durante 15 minutos todos los d\u00edas para hablar sobre el progreso y asegurarse de que la cantidad de trabajo asignado sea la adecuada. An\u00e1lisis retrospectivo del sprint: Cuando finaliza el proceso, el Scrum Master organiza una reuni\u00f3n retrospectiva del sprint para evaluar qu\u00e9 trabajo se realiz\u00f3, agregar cualquier tarea incompleta a la lista de trabajo pendiente y prepararse para el siguiente sprint. 3) Define los siguientes t\u00e9rminos: -Product backlog: El Product backlog (o pila de producto) es un listado de todas las tareas que se pretenden hacer durante el desarrollo de un proyecto. Todas las tareas deben listarse en el Product backlog, para que est\u00e9n visibles ante todo el equipo y se pueda tener una visi\u00f3n panor\u00e1mica de todo lo que se espera realizar. -Sprint backlog: El Sprint backlog es la suma del objetivo del sprint, los elementos del Product backlog elegidos para el sprint, m\u00e1s un plan de acci\u00f3n de c\u00f3mo crear el incremento de producto. Es uno de los 3 artefactos de Scrum y se construye durante el evento del Sprint Planning. Es un plan realizado por y para los Developers. 4) En la terminolog\u00eda Scrum qu\u00e9 t\u00e9rminos se utilizan como sin\u00f3nimo de: Jefe de proyecto: Scrum Master Cliente: Stakeholder Equipo de desarrollo: Scrum Team 5) Haz un resumen de los requisitos para poder utilizar Scrum . Cultura de empresa basada en trabajo en equipo, delegaci\u00f3n, creatividad y mejora continua. Compromiso del cliente en la direcci\u00f3n de los resultados del proyecto, gesti\u00f3n del ROI y disponibilidad para poder colaborar. Compromiso de la direcci\u00f3n de la organizaci\u00f3n para resolver problemas end\u00e9micos y realizar cambios organizativos, formando equipos autogestionados y multidisciplinares y fomentando una cultura de gesti\u00f3n basada en la colaboraci\u00f3n y en la facilitaci\u00f3n llevada a cabo por l\u00edderes al servicio del equipo. Compromiso conjunto y colaboraci\u00f3n de los miembros del equipo. Relaci\u00f3n entre proveedor y cliente basada en ganar-ganar, colaboraci\u00f3n y transparencia. Facilidad para realizar cambios en el proyecto. Tama\u00f1o de cada equipo entre 5 y 9 personas (con t\u00e9cnicas espec\u00edficas de planificaci\u00f3n y coordinaci\u00f3n cuando varios equipos trabajan en el mismo proyecto). Equipo trabajando en un mismoespacio c para maximizar la comunicaci\u00f3n. Dedicaci\u00f3n del equipo a tiempo completo. Estabilidad de los miembros del equipo. 6) Explica los 5 valores de la Programaci\u00f3n Extrema . Comunicaci\u00f3n: Como comunicaci\u00f3n entendemos no solo una buena interacci\u00f3n interna entre los propios miembros del equipo de desarrolladores, sino tambi\u00e9n con los clientes. El objetivo es romper las barreras entre negocio y desarrollo. Para ello, la programaci\u00f3n XP promueve que todos los requisitos sean comunicados y trabajados con el equipo y no mediante documentaci\u00f3n. Simplicidad: Empezar con la soluci\u00f3n m\u00e1s simple es clave en la programaci\u00f3n XP. Esta metodolog\u00eda pone el foco en codificar las necesidades de hoy, no las de un futuro. Adem\u00e1s, tambi\u00e9n se simplifica el dise\u00f1o para agilizar el desarrollo y facilitar el mantenimiento. Para conservar la simplicidad hay que mantener la refactorizaci\u00f3n del c\u00f3digo, as\u00ed podremos preservar el c\u00f3digo simple a medida que va creciendo. Feedback: Una de las mayores ventajas de que el cliente est\u00e9 integrado en el proyecto es que su opini\u00f3n sobre el estado de este lo podemos conocer en tiempo real. Gracias a que se hacen ciclos muy cortos de presentaci\u00f3n de resultados, se minimiza el riesgo de tener que rehacer partes que no cumplen con las expectativas del cliente. Tambi\u00e9n, por otro lado, ayuda a los programadores a centrarse en las tareas m\u00e1s importantes. Respeto: El respeto mutuo es fundamental para que un equipo pueda trabajar de forma eficiente y ofrecer un buen rendimiento. Implica desde que un desarrollador no realice modificaciones que puedan tener un impacto negativo en el trabajo de un compa\u00f1ero hasta la forma de llegar al cliente. El respeto se manifiesta de varias formas y todas son cruciales para una mejor autoestima en el equipo, que lleva consigo un mayor ritmo de producci\u00f3n. Valent\u00eda: Dise\u00f1ar y programar para hoy y no para ma\u00f1ana implica valent\u00eda en la metodolog\u00eda XP, as\u00ed como reconocer los errores tan pronto como se detecten. Ning\u00fan miembro del equipo puede perder el tiempo en intentar hacer de menos su responsabilidad en un error cometido, ya que esto significa dejar de centrarse en otras cosas e impedir\u00e1 avanzar al resto, por lo que la productividad bajar\u00e1. 7) \u00bfCu\u00e1les son las caracter\u00edsticas distintivas de XP frente a otras metodolog\u00edas \u00e1giles? Expl\u00edcalas. El juego de la planificaci\u00f3n. Es un permanente di\u00e1logo entre las partes empresarial (deseable) y t\u00e9cnica (posible). Peque\u00f1as entregas. Cada versi\u00f3n debe de ser tan peque\u00f1a como fuera posible, conteniendo los requisitos de negocios m\u00e1s importantes, las versiones tiene que tener sentido como un todo, me explico no puedes implementar media caracter\u00edstica y lanzar la versi\u00f3n. Planifica para 1 mes o 2, en lugar que para seis meses o un a\u00f1o, las compa\u00f1\u00edas que entregan software muy voluminoso no son capaces de hacerlo con mucha frecuencia. Met\u00e1fora. Una met\u00e1fora es una historia que todo el mundo puede contar acerca de c\u00f3mo funciona el sistema. Algunas veces podremos encontrar met\u00e1foras sencillas \u00abPrograma de gesti\u00f3n de compras, ventas, con gesti\u00f3n de cartera y almac\u00e9n\u00bb. Las met\u00e1foras ayudan a cualquier persona a entender el objeto del programa. Dise\u00f1o sencillo. Cuando implementamos nuevas caracter\u00edsticas en nuestros programas nos planteamos la manera de hacerlo lo m\u00e1s simple posible, despu\u00e9s de implementar esta caracter\u00edstica, nos preguntamos c\u00f3mo hacer el programa m\u00e1s simple sin perder funcionalidad, este proceso se le denomina recodificar o refactorizar (refactoring). Esto a veces nos puede llevar a hacer mas trabajo del necesario, pero a la vez estaremos preparando nuestro sistema para que en un futuro acepte nuevos cambios y pueda albergar nuevas caracter\u00edsticas. No debemos de recodificar ante especulaciones si no solo cuando el sistema te lo pida. Pruebas. No debe existir ninguna caracter\u00edstica en el programa que no haya sido probada, los programadores escriben pruebas para chequear el correcto funcionamiento del programa, los clientes realizan pruebas funcionales. El resultado es un programa m\u00e1s seguro que conforme pasa el tiempo es capaz de aceptar nuevos cambios. Refactorizaci\u00f3n. Cuando implementamos nuevas caracter\u00edsticas en nuestros programas nos planteamos la manera de hacerlo lo m\u00e1s simple posible, despu\u00e9s de implementar esta caracter\u00edstica, nos preguntamos c\u00f3mo hacer el programa m\u00e1s simple sin perder funcionalidad, este proceso se le denomina recodificar o refactorizar (refactoring). Esto a veces nos puede llevar a hacer m\u00e1s trabajo del necesario, pero a la vez estaremos preparando nuestro sistema para que en un futuro acepte nuevos cambios y pueda albergar nuevas caracter\u00ed\u00adsticas. No debemos de recodificar ante especulaciones si no solo cuando el sistema te lo pida. Programaci\u00f3n por parejas. Todo el c\u00f3digo de producci\u00f3n lo escriben dos personas frente al ordenador, con un s\u00f3lo rat\u00f3n y un s\u00f3lo teclado. Cada miembro de la pareja juega su papel: uno codifica en el ordenador y piensa la mejor manera de hacerlo, el otro piensa m\u00e1s estrat\u00e9gicamente, \u00bfva a funcionar?, \u00bfpuede haber pruebas donde no funcione?, \u00bfhay forma de simplificar el sistema global para que el problema desaparezca? El emparejamiento es din\u00e1mico, puede estar emparejado por la ma\u00f1ana con una persona y por la tarde con otra, si tienes un trabajo sobre un \u00e1rea que no conoces muy bien puedes emparejarte con otra persona que si conozca ese \u00e1rea. Cualquier miembro del equipo se puede emparejar con cualquiera. Propiedad colectiva. Cualquiera que crea que puede aportar valor al c\u00f3digo en cualquier parcela puede hacerlo, ning\u00fan miembro del equipo es propietario del c\u00f3digo. Si alguien quiere hacer cambios en el c\u00f3digo puede hacerlo. Si hacemos el c\u00f3digo propietario, y necesitamos de su autor paraque lo cambie entonces estaremos alej\u00e1ndonos cada vez mas de la comprensi\u00f3n del problema, si necesitamos un cambio sobre una parte del c\u00f3digo lo hacemos y punto. XP propone un propiedad colectiva sobre el c\u00f3digo nadie conoce cada parte igual de bien pero todos conoce algo sobre cada parte, esto nos preparar\u00e1 para la sustituci\u00f3n no traum\u00e1tica de cada miembro del equipo. Integraci\u00f3n continua. El c\u00f3digo se debe integrar como m\u00ednimo una vez al d\u00eda, y realizar las pruebas sobre la totalidad del sistema. Una pareja de programadores se encargara de integrar todo el c\u00f3digo en una maquina y realizar todas las pruebas hasta que estas funcionen al 100% cuarenta horas semanales . Si queremos estar frescos y motivados cada ma\u00f1ana y cansado y satisfecho cada noche. El viernes quiero estar cansado y satisfecho para sentir que tengo dos d\u00edas para pensar en algo distinto y volver el lunes lleno de pasi\u00f3n e ideas. Esto requiere que trabajemos 40 horas a la semana, mucha gente no puede estar m\u00e1s de 35 horas concentrada a la semana, otros pueden llegar hasta 45 pero ninguno puede llegar a 60 horas durante varias semanas y aun seguir fresco, creativo y confiado. Las horas extras son s\u00edntoma de serios problemas en el proyecto, la regla de XP dice nunca 2 semanas seguidas realizando horas extras. Cliente en casa. Un cliente real debe sentarse con el equipo de programadores, estar disponible para responder a sus preguntas, resolver discusiones y fijar las prioridades. Lo dif\u00edcil es que el cliente nos ceda una persona que conozca el negocio para que se integre en el equipo normalmente estos elementos son muy valiosos, pero debemos de hacerles ver que ser\u00e1 mejor para su negocio tener un software pronto en funcionamiento, y esto no implica que el cliente no pueda realizar cualquier otro trabajo. Est\u00e1ndares de codificaci\u00f3n. Si los programadores van a estar tocando partes distintas del sistema, intercambiando compa\u00f1eros, haciendo refactoring, debemos de establecer un est\u00e1ndar de codificaci\u00f3n aceptado e implantado por todo el equipo.","title":"Actividades Ciclo de vida del sofware y Kanban Scrum"},{"location":"Actividades%20Ciclo%20de%20vida%20del%20sofware%20y%20Kanban-Scrum/#actividades-ciclo-de-vida-del-software","text":"","title":"Actividades: Ciclo de vida del software"},{"location":"Actividades%20Ciclo%20de%20vida%20del%20sofware%20y%20Kanban-Scrum/#1-define-ciclo-de-vida-del-software","text":"El ciclo de vida del desarrollo de software es la estructura que contiene los procesos, actividades y tareas relacionadas con el desarrollo y mantenimiento de un producto de software, abarcando la vida completa del sistema, desde la definici\u00f3n de los requisitos hasta la finalizaci\u00f3n de su uso. 2) Nombra las fases principales del desarrollo de software y explica brevemente qu\u00e9 se hace en cada una de ellas. Planificaci\u00f3n: Antes de iniciar un proyecto de desarrollo de un sistema de informaci\u00f3n, es necesario hacer ciertas tareas que influir\u00e1n decisivamente en el \u00e9xito del mismo. Dichas tareas no est\u00e1n sujetas a plazos. Algunas de las tareas incluyen actividades como la determinaci\u00f3n del \u00e1mbito del proyecto, la realizaci\u00f3n de un estudio de viabilidad, el an\u00e1lisis de los riesgos asociados, la estimaci\u00f3n del coste del proyecto, su planificaci\u00f3n temporal y la asignaci\u00f3n de recursos a las diferentes etapas del proyecto. An\u00e1lisis: Hay que averiguar qu\u00e9 es exactamente lo que tiene que hacer el software. Esta etapa corresponde al proceso a trav\u00e9s del cual se intenta descubrir qu\u00e9 es lo que realmente se necesita y se llega a una comprensi\u00f3n adecuada de los requerimientos del sistema (las caracter\u00edsticas que el sistema debe poseer). Dise\u00f1o: En esta fase se estudian posibles opciones de implementaci\u00f3n para el software que hay que construir, as\u00ed como decidir la estructura general del mismo. El dise\u00f1o es una etapa compleja y su proceso debe realizarse de manera iterativa. Implementaci\u00f3n: En esta fase hay que elegir las herramientas adecuadas, un entorno de desarrollo que facilite el trabajo y un lenguaje de programaci\u00f3n apropiado para el tipo de software a construir. Esta elecci\u00f3n depender\u00e1 tanto de las decisiones de dise\u00f1o tomadas como del entorno en el que el software deba funcionar. Pruebas: La fase de pruebas busca detectar los fallos cometidos en las etapas anteriores para corregirlos. Por supuesto, lo ideal es hacerlo antes de que el usuario final se los encuentre. Se dice que una prueba es un \u00e9xito si se detecta alg\u00fan error. Instalaci\u00f3n: La siguiente fase es poner el software en funcionamiento, por lo que hay que planificar el entorno teniendo en cuenta las dependencias existentes entre los diferentes componentes del mismo. Uso y mantenimiento: Esta es una de las fases m\u00e1s importantes del ciclo de vida de desarrollo del software. Puesto que el software ni se rompe ni se desgasta con el uso, su mantenimiento incluye tres puntos diferenciados: -Eliminar los defectos detectados durante su vida \u00fatil (mantenimiento correctivo). -Adaptarlo a nuevas necesidades (mantenimiento adaptativo). -A\u00f1adirle nuevas funcionalidades (mantenimiento perfectivo). 3) Explica brevemente en qu\u00e9 consiste el modelo en cascada cuando hablamos de desarrollo de software. El desarrollo en cascada es un procedimiento lineal que se caracteriza por dividir los procesos de desarrollo en sucesivas fases de proyecto. Al contrario que en los modelos iterativos, cada una de estas fases se ejecuta tan solo una vez. Los resultados de cada una de las fases sirven como hip\u00f3tesis de partida para la siguiente. Este procedimiento se utiliza, especialmente, en el desarrollo de software. 4) Ventajas e inconvenientes del modelo en cascada. Ventajas: -Una estructura sencilla gracias a unas fases de proyecto claramente diferenciadas. -Buena documentaci\u00f3n del proceso de desarrollo a trav\u00e9s de unos hitos bien definidos. -Los costes y la carga de trabajo se pueden estimar al comenzar el proyecto. -Aquellos proyectos que se estructuran en base al modelo en cascada se pueden representar cronol\u00f3gicamente de forma sencilla. Inconvenientes: -Por norma general, los proyectos m\u00e1s complejos o de varios niveles no permiten su divisi\u00f3n en fases de proyecto claramente diferenciadas. -Poco margen para realizar ajustes a lo largo del proyecto debido a un cambio en las exigencias. -El usuario final no se integra en el proceso de producci\u00f3n hasta que no termina la programaci\u00f3n. -En ocasiones, los fallos solo se detectan una vez finalizado el proceso de desarrollo. 5) \u00bfQu\u00e9 se entiende por verificaci\u00f3n? \u00bfY por validaci\u00f3n? -La verificaci\u00f3n de software es una disciplina de la ingenier\u00eda de software cuyo objetivo es asegurar que el software satisface por completo todos los requisitos esperados. -La validaci\u00f3n de software es un proceso que demuestra a partir de documentos que el sistema cumple con las funciones de las cuales fue designado, de acuerdo con las especificaciones de los requisitos del usuario y con la garant\u00eda de seguridad y trazabilidad de informaciones. 6) Explica c\u00f3mo funciona el modelo de desarrollo mediante creaci\u00f3n de prototipos. Un modelo prototipo o modelo de desarrollo evolutivo es utilizado principalmente en el desarrollo de software para ofrecer al usuario una visi\u00f3n previa de c\u00f3mo ser\u00e1 el programa o sistema. Se le dice de desarrollo evolutivo al modelo de prototipo porque evoluciona hasta convertirse en el producto final.El modelo de prototipos se centra en un dise\u00f1o r\u00e1pido que representa las caracter\u00edsticas principales del programa que el usuario podr\u00e1 ver o utilizar. De esta manera pueden probarlo y dar su opini\u00f3n sobre distintos aspectos como la usabilidad, la utilidad o el rendimiento, entre otras.El prototipo se puede modificar cuando sea necesario y todos los resultados obtenidos de las presentaciones y pruebas se deben anotar para utilizar posteriormente como ayuda en el desarrollo del producto final. ## Actividades: Kanban y Scrum 1) Haz un resumen de la metodolog\u00eda Kanban e indica sus diferencias frente a SCRUM. Kanban es una forma de ayudar a los equipos a encontrar un equilibrio entre el trabajo que necesitan hacer y la disponibilidad de cada miembro del equipo. La metodolog\u00eda Kanban se basa en una filosof\u00eda centrada en la mejora continua, donde las tareas se \u201cextraen\u201d de una lista de acciones pendientes en un flujo de trabajo constante. La metodolog\u00eda Kanban se implementa por medio de tableros Kanban. Se trata de un m\u00e9todo visual de gesti\u00f3n de proyectos que permite a los equipos visualizar sus flujos de trabajo y la carga de trabajo. En un tablero Kanban, el trabajo se muestra en un proyecto en forma de tablero organizado por columnas. Tradicionalmente, cada columna representa una etapa del trabajo. Scrum es m\u00e1s estricto que Kanban. Este marco incluye un conjunto espec\u00edfico de reglas que los equipos deben seguir, mientras que Kanban se usa m\u00e1s para visualizar el trabajo. Muchos equipos implementan Scrum en un tablero Kanban, pero en esos casos, la metodolog\u00eda sigue siendo Scrum, no Kanban. Esta \u00faltima, m\u00e1s que una metodolog\u00eda estricta, es una forma de visualizar el trabajo. Scrum tiene un l\u00edmite de tiempo, Kanban es flexible. Scrum se ejecuta en sprints, que suelen ser ciclos de trabajo de dos semanas. Al final de un sprint, tienes un conjunto de tareas terminadas, sin importar cu\u00e1les sean. Los tableros Kanban no necesariamente tienen una fecha de inicio o finalizaci\u00f3n. De hecho a menudo se usan tableros Kanban para visualizar procesos en curso. Las columnas del tablero Kanban se pueden organizar de diferentes formas. Cuando implementas un Scrum, es importante realizar un seguimiento del trabajo a medida que avanzas por las diferentes etapas. Sin embargo, en un tablero Kanban que no se basa en Scrum, las columnas pueden representar diferentes aspectos, no solo el estado; como, por ejemplo, el trabajo que se realizar\u00e1 cada mes, una retrospectiva que identifica las tareas que se completaron anteriormente, o cualquier otra cosa que necesites. En esto se diferencia de las reglas m\u00e1s definidas de Scrum. 2) Explica c\u00f3mo funciona SCRUM . Planificaci\u00f3n del sprint: Estos suelen durar dos semanas, aunque los equipos pueden realizar sprints m\u00e1s r\u00e1pidos o breves. Durante esta etapa, el Scrum Master y el equipo analizan el trabajo pendiente y determinan qu\u00e9 tareas realizar durante el Sprint. Reuniones diarias de actualizaci\u00f3n: Durante el transcurso del Scrum (tambi\u00e9n conocido como el \u201cciclo\u201d de Scrum), los equipos suelen reunirse durante 15 minutos todos los d\u00edas para hablar sobre el progreso y asegurarse de que la cantidad de trabajo asignado sea la adecuada. An\u00e1lisis retrospectivo del sprint: Cuando finaliza el proceso, el Scrum Master organiza una reuni\u00f3n retrospectiva del sprint para evaluar qu\u00e9 trabajo se realiz\u00f3, agregar cualquier tarea incompleta a la lista de trabajo pendiente y prepararse para el siguiente sprint. 3) Define los siguientes t\u00e9rminos: -Product backlog: El Product backlog (o pila de producto) es un listado de todas las tareas que se pretenden hacer durante el desarrollo de un proyecto. Todas las tareas deben listarse en el Product backlog, para que est\u00e9n visibles ante todo el equipo y se pueda tener una visi\u00f3n panor\u00e1mica de todo lo que se espera realizar. -Sprint backlog: El Sprint backlog es la suma del objetivo del sprint, los elementos del Product backlog elegidos para el sprint, m\u00e1s un plan de acci\u00f3n de c\u00f3mo crear el incremento de producto. Es uno de los 3 artefactos de Scrum y se construye durante el evento del Sprint Planning. Es un plan realizado por y para los Developers. 4) En la terminolog\u00eda Scrum qu\u00e9 t\u00e9rminos se utilizan como sin\u00f3nimo de: Jefe de proyecto: Scrum Master Cliente: Stakeholder Equipo de desarrollo: Scrum Team 5) Haz un resumen de los requisitos para poder utilizar Scrum . Cultura de empresa basada en trabajo en equipo, delegaci\u00f3n, creatividad y mejora continua. Compromiso del cliente en la direcci\u00f3n de los resultados del proyecto, gesti\u00f3n del ROI y disponibilidad para poder colaborar. Compromiso de la direcci\u00f3n de la organizaci\u00f3n para resolver problemas end\u00e9micos y realizar cambios organizativos, formando equipos autogestionados y multidisciplinares y fomentando una cultura de gesti\u00f3n basada en la colaboraci\u00f3n y en la facilitaci\u00f3n llevada a cabo por l\u00edderes al servicio del equipo. Compromiso conjunto y colaboraci\u00f3n de los miembros del equipo. Relaci\u00f3n entre proveedor y cliente basada en ganar-ganar, colaboraci\u00f3n y transparencia. Facilidad para realizar cambios en el proyecto. Tama\u00f1o de cada equipo entre 5 y 9 personas (con t\u00e9cnicas espec\u00edficas de planificaci\u00f3n y coordinaci\u00f3n cuando varios equipos trabajan en el mismo proyecto). Equipo trabajando en un mismoespacio c para maximizar la comunicaci\u00f3n. Dedicaci\u00f3n del equipo a tiempo completo. Estabilidad de los miembros del equipo. 6) Explica los 5 valores de la Programaci\u00f3n Extrema . Comunicaci\u00f3n: Como comunicaci\u00f3n entendemos no solo una buena interacci\u00f3n interna entre los propios miembros del equipo de desarrolladores, sino tambi\u00e9n con los clientes. El objetivo es romper las barreras entre negocio y desarrollo. Para ello, la programaci\u00f3n XP promueve que todos los requisitos sean comunicados y trabajados con el equipo y no mediante documentaci\u00f3n. Simplicidad: Empezar con la soluci\u00f3n m\u00e1s simple es clave en la programaci\u00f3n XP. Esta metodolog\u00eda pone el foco en codificar las necesidades de hoy, no las de un futuro. Adem\u00e1s, tambi\u00e9n se simplifica el dise\u00f1o para agilizar el desarrollo y facilitar el mantenimiento. Para conservar la simplicidad hay que mantener la refactorizaci\u00f3n del c\u00f3digo, as\u00ed podremos preservar el c\u00f3digo simple a medida que va creciendo. Feedback: Una de las mayores ventajas de que el cliente est\u00e9 integrado en el proyecto es que su opini\u00f3n sobre el estado de este lo podemos conocer en tiempo real. Gracias a que se hacen ciclos muy cortos de presentaci\u00f3n de resultados, se minimiza el riesgo de tener que rehacer partes que no cumplen con las expectativas del cliente. Tambi\u00e9n, por otro lado, ayuda a los programadores a centrarse en las tareas m\u00e1s importantes. Respeto: El respeto mutuo es fundamental para que un equipo pueda trabajar de forma eficiente y ofrecer un buen rendimiento. Implica desde que un desarrollador no realice modificaciones que puedan tener un impacto negativo en el trabajo de un compa\u00f1ero hasta la forma de llegar al cliente. El respeto se manifiesta de varias formas y todas son cruciales para una mejor autoestima en el equipo, que lleva consigo un mayor ritmo de producci\u00f3n. Valent\u00eda: Dise\u00f1ar y programar para hoy y no para ma\u00f1ana implica valent\u00eda en la metodolog\u00eda XP, as\u00ed como reconocer los errores tan pronto como se detecten. Ning\u00fan miembro del equipo puede perder el tiempo en intentar hacer de menos su responsabilidad en un error cometido, ya que esto significa dejar de centrarse en otras cosas e impedir\u00e1 avanzar al resto, por lo que la productividad bajar\u00e1. 7) \u00bfCu\u00e1les son las caracter\u00edsticas distintivas de XP frente a otras metodolog\u00edas \u00e1giles? Expl\u00edcalas. El juego de la planificaci\u00f3n. Es un permanente di\u00e1logo entre las partes empresarial (deseable) y t\u00e9cnica (posible). Peque\u00f1as entregas. Cada versi\u00f3n debe de ser tan peque\u00f1a como fuera posible, conteniendo los requisitos de negocios m\u00e1s importantes, las versiones tiene que tener sentido como un todo, me explico no puedes implementar media caracter\u00edstica y lanzar la versi\u00f3n. Planifica para 1 mes o 2, en lugar que para seis meses o un a\u00f1o, las compa\u00f1\u00edas que entregan software muy voluminoso no son capaces de hacerlo con mucha frecuencia. Met\u00e1fora. Una met\u00e1fora es una historia que todo el mundo puede contar acerca de c\u00f3mo funciona el sistema. Algunas veces podremos encontrar met\u00e1foras sencillas \u00abPrograma de gesti\u00f3n de compras, ventas, con gesti\u00f3n de cartera y almac\u00e9n\u00bb. Las met\u00e1foras ayudan a cualquier persona a entender el objeto del programa. Dise\u00f1o sencillo. Cuando implementamos nuevas caracter\u00edsticas en nuestros programas nos planteamos la manera de hacerlo lo m\u00e1s simple posible, despu\u00e9s de implementar esta caracter\u00edstica, nos preguntamos c\u00f3mo hacer el programa m\u00e1s simple sin perder funcionalidad, este proceso se le denomina recodificar o refactorizar (refactoring). Esto a veces nos puede llevar a hacer mas trabajo del necesario, pero a la vez estaremos preparando nuestro sistema para que en un futuro acepte nuevos cambios y pueda albergar nuevas caracter\u00edsticas. No debemos de recodificar ante especulaciones si no solo cuando el sistema te lo pida. Pruebas. No debe existir ninguna caracter\u00edstica en el programa que no haya sido probada, los programadores escriben pruebas para chequear el correcto funcionamiento del programa, los clientes realizan pruebas funcionales. El resultado es un programa m\u00e1s seguro que conforme pasa el tiempo es capaz de aceptar nuevos cambios. Refactorizaci\u00f3n. Cuando implementamos nuevas caracter\u00edsticas en nuestros programas nos planteamos la manera de hacerlo lo m\u00e1s simple posible, despu\u00e9s de implementar esta caracter\u00edstica, nos preguntamos c\u00f3mo hacer el programa m\u00e1s simple sin perder funcionalidad, este proceso se le denomina recodificar o refactorizar (refactoring). Esto a veces nos puede llevar a hacer m\u00e1s trabajo del necesario, pero a la vez estaremos preparando nuestro sistema para que en un futuro acepte nuevos cambios y pueda albergar nuevas caracter\u00ed\u00adsticas. No debemos de recodificar ante especulaciones si no solo cuando el sistema te lo pida. Programaci\u00f3n por parejas. Todo el c\u00f3digo de producci\u00f3n lo escriben dos personas frente al ordenador, con un s\u00f3lo rat\u00f3n y un s\u00f3lo teclado. Cada miembro de la pareja juega su papel: uno codifica en el ordenador y piensa la mejor manera de hacerlo, el otro piensa m\u00e1s estrat\u00e9gicamente, \u00bfva a funcionar?, \u00bfpuede haber pruebas donde no funcione?, \u00bfhay forma de simplificar el sistema global para que el problema desaparezca? El emparejamiento es din\u00e1mico, puede estar emparejado por la ma\u00f1ana con una persona y por la tarde con otra, si tienes un trabajo sobre un \u00e1rea que no conoces muy bien puedes emparejarte con otra persona que si conozca ese \u00e1rea. Cualquier miembro del equipo se puede emparejar con cualquiera. Propiedad colectiva. Cualquiera que crea que puede aportar valor al c\u00f3digo en cualquier parcela puede hacerlo, ning\u00fan miembro del equipo es propietario del c\u00f3digo. Si alguien quiere hacer cambios en el c\u00f3digo puede hacerlo. Si hacemos el c\u00f3digo propietario, y necesitamos de su autor paraque lo cambie entonces estaremos alej\u00e1ndonos cada vez mas de la comprensi\u00f3n del problema, si necesitamos un cambio sobre una parte del c\u00f3digo lo hacemos y punto. XP propone un propiedad colectiva sobre el c\u00f3digo nadie conoce cada parte igual de bien pero todos conoce algo sobre cada parte, esto nos preparar\u00e1 para la sustituci\u00f3n no traum\u00e1tica de cada miembro del equipo. Integraci\u00f3n continua. El c\u00f3digo se debe integrar como m\u00ednimo una vez al d\u00eda, y realizar las pruebas sobre la totalidad del sistema. Una pareja de programadores se encargara de integrar todo el c\u00f3digo en una maquina y realizar todas las pruebas hasta que estas funcionen al 100% cuarenta horas semanales . Si queremos estar frescos y motivados cada ma\u00f1ana y cansado y satisfecho cada noche. El viernes quiero estar cansado y satisfecho para sentir que tengo dos d\u00edas para pensar en algo distinto y volver el lunes lleno de pasi\u00f3n e ideas. Esto requiere que trabajemos 40 horas a la semana, mucha gente no puede estar m\u00e1s de 35 horas concentrada a la semana, otros pueden llegar hasta 45 pero ninguno puede llegar a 60 horas durante varias semanas y aun seguir fresco, creativo y confiado. Las horas extras son s\u00edntoma de serios problemas en el proyecto, la regla de XP dice nunca 2 semanas seguidas realizando horas extras. Cliente en casa. Un cliente real debe sentarse con el equipo de programadores, estar disponible para responder a sus preguntas, resolver discusiones y fijar las prioridades. Lo dif\u00edcil es que el cliente nos ceda una persona que conozca el negocio para que se integre en el equipo normalmente estos elementos son muy valiosos, pero debemos de hacerles ver que ser\u00e1 mejor para su negocio tener un software pronto en funcionamiento, y esto no implica que el cliente no pueda realizar cualquier otro trabajo. Est\u00e1ndares de codificaci\u00f3n. Si los programadores van a estar tocando partes distintas del sistema, intercambiando compa\u00f1eros, haciendo refactoring, debemos de establecer un est\u00e1ndar de codificaci\u00f3n aceptado e implantado por todo el equipo.","title":"1. Define \"Ciclo de vida del software\""},{"location":"Actividades%20de%20Optimizaci%C3%B3n/","text":"Actividades de Optimizaci\u00f3n 1)\u00bfQu\u00e9 se entiende por hediondez del c\u00f3digo? Pon al menos 5 ejemplos. En programaci\u00f3n, la hediondez del c\u00f3digo (tambi\u00e9n conocida como code smell ) es cualquier s\u00edntoma en el c\u00f3digo fuente de un programa que posiblemente indica un problema m\u00e1s profundo. Las hediondeces del c\u00f3digo usualmente no son[ bugs de programaci\u00f3n, no son t\u00e9cnicamente incorrectos y en realidad no impiden que el programa funcione correctamente. En cambio, indican deficiencias en el dise\u00f1o de software que pueden ralentizar el desarrollo o aumentar el riesgo de errores o fallos en el futuro. Ejemplos son: C\u00f3digo duplicado: Existe c\u00f3digo id\u00e9ntico o muy similar en m\u00e1s de una ubicaci\u00f3n. M\u00e9todo grande: Un m\u00e9todo, funci\u00f3n o procedimiento que ha crecido hasta hacerse demasiado grande. Clase grande: Una clase que ha crecido hasta hacerse demasiado grande. Demasiados par\u00e1metros: Una larga lista de par\u00e1metros de un procedimiento o funci\u00f3n empeora la legibilidad y la calidad del c\u00f3digo. Envidia de caracter\u00edsticas: Una clase que usa excesivamente m\u00e9todos de otra clase. 2)\u00bfQu\u00e9 tipo de herramienta utilizamos para hacer an\u00e1lisis est\u00e1tico del c\u00f3digo? El an\u00e1lisis de c\u00f3digo est\u00e1tico consta de una serie de comprobaciones automatizadas que se realizan en el c\u00f3digo fuente. Una herramienta de an\u00e1lisis est\u00e1tico escanea el c\u00f3digo en busca de errores y vulnerabilidades comunes conocidas, como fugas de memoria o desbordamientos de b\u00fafer. Algunas de las herramientas de an\u00e1lisis est\u00e1tico del c\u00f3digo m\u00e1s destacables son: -SonarQube: Es un software open source que permite hacer an\u00e1lisis est\u00e1ticos del c\u00f3digo. Obtiene m\u00e9tricas que permiten mejorar la calidad del c\u00f3digo y descubrir evidencias de los problemas existentes en el c\u00f3digo. -FindBugs: Es un analizador de c\u00f3digo est\u00e1tico de c\u00f3digo abierto. Detecta posibles errores en los programas de Java y los clasifica seg\u00fan la gravedad que presenten, por lo que ayuda a detectar cuales tienen mayor impacto en el desarrollo del programa. -PMD: Es un analizador de c\u00f3digo fuente. Encuentra fallas de programaci\u00f3n comunes como variables no utilizadas, bloques catch vac\u00edos, creaci\u00f3n de objetos innecesarios, etc. -Lint: Es una herramienta a cargo de la mejora del c\u00f3digo a trav\u00e9s del an\u00e1lisis del c\u00f3digo fuente, con el objetivo de identificar fallos o problemas en el sistema. 3)\u00bfQu\u00e9 sitios web nos permiten hacer an\u00e1lisis est\u00e1tico del c\u00f3digo o Continuous Inspection? Algunos de los sitios web que nos permiten hacer an\u00e1lisis est\u00e1tico del c\u00f3digo son: -Review Board: Es una herramienta de c\u00f3digo abierto basada en la web para la revisi\u00f3n de c\u00f3digos que te permite realizar revisiones de c\u00f3digo antes y despu\u00e9s de la autorizaci\u00f3n, adem\u00e1s proporciona una comparaci\u00f3n gr\u00e1fica de los cambios en tu c\u00f3digo. -Crucible: Es un conjunto de herramientas comerciales que permite revisar el c\u00f3digo, discutir cambios en los planes e identificar errores en una serie de sistemas de control de versiones. Soporta un gran n\u00famero de sistemas de control de versiones y te permite hacer comentarios en l\u00ednea dentro de la vista de diferencias para se\u00f1alar exactamente a qu\u00e9 quieres referirte espec\u00edficamente. -Phabricator: Es una lista de herramientas de c\u00f3digo abierto de Phacility que te ayudan a revisar el c\u00f3digo. Mientras que puedes descargar e instalar el conjunto de herramientas de revisi\u00f3n de c\u00f3digo en tu servidor, Phacility tambi\u00e9n proporciona una versi\u00f3n en la nube de Phabricator. -Collaborator: Es una herramienta de revisi\u00f3n de c\u00f3digos y documentos para equipos de desarrollo. Permite a los equipos revisar los documentos de dise\u00f1o, soporta un gran n\u00famero de sistemas de control de versiones, permite la presentaci\u00f3n de informes y el an\u00e1lisis de m\u00e9tricas clave relacionadas con su proceso de revisi\u00f3n de c\u00f3digos y, adem\u00e1s, ayuda en la gesti\u00f3n de la auditor\u00eda y el seguimiento de errores. 4) Instala en Netbeans el plugin SpotBugs, si no lo tienes a\u00fan instalado. 5) Realiza an\u00e1lisis est\u00e1tico de c\u00f3digo para las clases del proyecto con bucle infinito. 6) Indica al menos un code smell relevante de cada clase. Explica c\u00f3mo podr\u00eda solucionarse. Clase Customer: \"Feature envy\": esta clase tiene una gran cantidad de atributos que pertenecen a la clase \"Order\", lo que indica que hay una posible violaci\u00f3n del principio de responsabilidad \u00fanica (SRP). Para solucionar esto, se podr\u00eda mover la l\u00f3gica de la clase \"Order\" a una nueva clase, lo que permitir\u00eda que ambas clases se encarguen de su propia l\u00f3gica. Clase Product: \"Divergent change\": esta clase tiene una gran cantidad de atributos que pueden estar relacionados con diferentes comportamientos o responsabilidades. Para solucionar esto, se podr\u00eda considerar la posibilidad de dividir la clase en diferentes clases que se encarguen de comportamientos espec\u00edficos. Clase Order: \"Shotgun surgery\": esta clase tiene una gran cantidad de m\u00e9todos que se encargan de diferentes aspectos de la l\u00f3gica de la orden, lo que indica que un cambio en un m\u00e9todo podr\u00eda afectar a varios otros. Para solucionar esto, se podr\u00eda considerar la posibilidad de mover algunos de los m\u00e9todos a una nueva clase que se encargue espec\u00edficamente de la l\u00f3gica de la orden. 7)\u00bfQu\u00e9 es la refactorizaci\u00f3n? La refactorizaci\u00f3n es un cambio realizado en la estructura interna del c\u00f3digo del software para hacerlo m\u00e1s f\u00e1cil de entender y m\u00e1s barato de modificar sin cambiar su comportamiento observable. 8)\u00bfQu\u00e9 t\u00e9cnicas se utilizan a menudo a la hora de refactorizar? La refactorizaci\u00f3n se realiza a menudo como parte del proceso de desarrollo del software: los desarrolladores alternan la inserci\u00f3n de nuevas funcionalidades y casos de prueba con la refactorizaci\u00f3n del c\u00f3digo para mejorar su consistencia interna y su claridad. T\u00e9cnicas para refactorizar que se utilizan a menudo son: Simplificaci\u00f3n de las llamadas a m\u00e9todo Cambiar el nombre de los m\u00e9todos. A\u00f1adir par\u00e1metros o eliminarlos. Sustituir par\u00e1metros por m\u00e9todos expl\u00edcitos. Sustituir c\u00f3digo defectuoso por excepciones.","title":"**Actividades de Optimizaci\u00f3n**"},{"location":"Actividades%20de%20Optimizaci%C3%B3n/#actividades-de-optimizacion","text":"1)\u00bfQu\u00e9 se entiende por hediondez del c\u00f3digo? Pon al menos 5 ejemplos. En programaci\u00f3n, la hediondez del c\u00f3digo (tambi\u00e9n conocida como code smell ) es cualquier s\u00edntoma en el c\u00f3digo fuente de un programa que posiblemente indica un problema m\u00e1s profundo. Las hediondeces del c\u00f3digo usualmente no son[ bugs de programaci\u00f3n, no son t\u00e9cnicamente incorrectos y en realidad no impiden que el programa funcione correctamente. En cambio, indican deficiencias en el dise\u00f1o de software que pueden ralentizar el desarrollo o aumentar el riesgo de errores o fallos en el futuro. Ejemplos son: C\u00f3digo duplicado: Existe c\u00f3digo id\u00e9ntico o muy similar en m\u00e1s de una ubicaci\u00f3n. M\u00e9todo grande: Un m\u00e9todo, funci\u00f3n o procedimiento que ha crecido hasta hacerse demasiado grande. Clase grande: Una clase que ha crecido hasta hacerse demasiado grande. Demasiados par\u00e1metros: Una larga lista de par\u00e1metros de un procedimiento o funci\u00f3n empeora la legibilidad y la calidad del c\u00f3digo. Envidia de caracter\u00edsticas: Una clase que usa excesivamente m\u00e9todos de otra clase. 2)\u00bfQu\u00e9 tipo de herramienta utilizamos para hacer an\u00e1lisis est\u00e1tico del c\u00f3digo? El an\u00e1lisis de c\u00f3digo est\u00e1tico consta de una serie de comprobaciones automatizadas que se realizan en el c\u00f3digo fuente. Una herramienta de an\u00e1lisis est\u00e1tico escanea el c\u00f3digo en busca de errores y vulnerabilidades comunes conocidas, como fugas de memoria o desbordamientos de b\u00fafer. Algunas de las herramientas de an\u00e1lisis est\u00e1tico del c\u00f3digo m\u00e1s destacables son: -SonarQube: Es un software open source que permite hacer an\u00e1lisis est\u00e1ticos del c\u00f3digo. Obtiene m\u00e9tricas que permiten mejorar la calidad del c\u00f3digo y descubrir evidencias de los problemas existentes en el c\u00f3digo. -FindBugs: Es un analizador de c\u00f3digo est\u00e1tico de c\u00f3digo abierto. Detecta posibles errores en los programas de Java y los clasifica seg\u00fan la gravedad que presenten, por lo que ayuda a detectar cuales tienen mayor impacto en el desarrollo del programa. -PMD: Es un analizador de c\u00f3digo fuente. Encuentra fallas de programaci\u00f3n comunes como variables no utilizadas, bloques catch vac\u00edos, creaci\u00f3n de objetos innecesarios, etc. -Lint: Es una herramienta a cargo de la mejora del c\u00f3digo a trav\u00e9s del an\u00e1lisis del c\u00f3digo fuente, con el objetivo de identificar fallos o problemas en el sistema. 3)\u00bfQu\u00e9 sitios web nos permiten hacer an\u00e1lisis est\u00e1tico del c\u00f3digo o Continuous Inspection? Algunos de los sitios web que nos permiten hacer an\u00e1lisis est\u00e1tico del c\u00f3digo son: -Review Board: Es una herramienta de c\u00f3digo abierto basada en la web para la revisi\u00f3n de c\u00f3digos que te permite realizar revisiones de c\u00f3digo antes y despu\u00e9s de la autorizaci\u00f3n, adem\u00e1s proporciona una comparaci\u00f3n gr\u00e1fica de los cambios en tu c\u00f3digo. -Crucible: Es un conjunto de herramientas comerciales que permite revisar el c\u00f3digo, discutir cambios en los planes e identificar errores en una serie de sistemas de control de versiones. Soporta un gran n\u00famero de sistemas de control de versiones y te permite hacer comentarios en l\u00ednea dentro de la vista de diferencias para se\u00f1alar exactamente a qu\u00e9 quieres referirte espec\u00edficamente. -Phabricator: Es una lista de herramientas de c\u00f3digo abierto de Phacility que te ayudan a revisar el c\u00f3digo. Mientras que puedes descargar e instalar el conjunto de herramientas de revisi\u00f3n de c\u00f3digo en tu servidor, Phacility tambi\u00e9n proporciona una versi\u00f3n en la nube de Phabricator. -Collaborator: Es una herramienta de revisi\u00f3n de c\u00f3digos y documentos para equipos de desarrollo. Permite a los equipos revisar los documentos de dise\u00f1o, soporta un gran n\u00famero de sistemas de control de versiones, permite la presentaci\u00f3n de informes y el an\u00e1lisis de m\u00e9tricas clave relacionadas con su proceso de revisi\u00f3n de c\u00f3digos y, adem\u00e1s, ayuda en la gesti\u00f3n de la auditor\u00eda y el seguimiento de errores. 4) Instala en Netbeans el plugin SpotBugs, si no lo tienes a\u00fan instalado. 5) Realiza an\u00e1lisis est\u00e1tico de c\u00f3digo para las clases del proyecto con bucle infinito. 6) Indica al menos un code smell relevante de cada clase. Explica c\u00f3mo podr\u00eda solucionarse. Clase Customer: \"Feature envy\": esta clase tiene una gran cantidad de atributos que pertenecen a la clase \"Order\", lo que indica que hay una posible violaci\u00f3n del principio de responsabilidad \u00fanica (SRP). Para solucionar esto, se podr\u00eda mover la l\u00f3gica de la clase \"Order\" a una nueva clase, lo que permitir\u00eda que ambas clases se encarguen de su propia l\u00f3gica. Clase Product: \"Divergent change\": esta clase tiene una gran cantidad de atributos que pueden estar relacionados con diferentes comportamientos o responsabilidades. Para solucionar esto, se podr\u00eda considerar la posibilidad de dividir la clase en diferentes clases que se encarguen de comportamientos espec\u00edficos. Clase Order: \"Shotgun surgery\": esta clase tiene una gran cantidad de m\u00e9todos que se encargan de diferentes aspectos de la l\u00f3gica de la orden, lo que indica que un cambio en un m\u00e9todo podr\u00eda afectar a varios otros. Para solucionar esto, se podr\u00eda considerar la posibilidad de mover algunos de los m\u00e9todos a una nueva clase que se encargue espec\u00edficamente de la l\u00f3gica de la orden. 7)\u00bfQu\u00e9 es la refactorizaci\u00f3n? La refactorizaci\u00f3n es un cambio realizado en la estructura interna del c\u00f3digo del software para hacerlo m\u00e1s f\u00e1cil de entender y m\u00e1s barato de modificar sin cambiar su comportamiento observable. 8)\u00bfQu\u00e9 t\u00e9cnicas se utilizan a menudo a la hora de refactorizar? La refactorizaci\u00f3n se realiza a menudo como parte del proceso de desarrollo del software: los desarrolladores alternan la inserci\u00f3n de nuevas funcionalidades y casos de prueba con la refactorizaci\u00f3n del c\u00f3digo para mejorar su consistencia interna y su claridad. T\u00e9cnicas para refactorizar que se utilizan a menudo son: Simplificaci\u00f3n de las llamadas a m\u00e9todo Cambiar el nombre de los m\u00e9todos. A\u00f1adir par\u00e1metros o eliminarlos. Sustituir par\u00e1metros por m\u00e9todos expl\u00edcitos. Sustituir c\u00f3digo defectuoso por excepciones.","title":"Actividades de Optimizaci\u00f3n"},{"location":"Control%20de%20versiones/","text":"Control de versiones 1. Adem\u00e1s de Git, \u00bfque otros sistemas de control de versiones existen? Existen otros sistemas como por ejemplo CVS, Subversion y Mercurial que son los m\u00e1s conocidos aparte de Git. 2. En Git, \u00bfqu\u00e9 tres \u00e1reas existen? Las \u00e1reas que existen son: working directory, stage area y repository. 5. En Git, \u00bfpara qu\u00e9 sirve el comando git config? Sirve para configurar la informaci\u00f3n del usuario utilizada en todos los repositorios locales. 6. En Git, \u00bfpara qu\u00e9 sirve el comando git init? Sirve para inicializar un directorio existente como un repositorio de git. 7. En Git, \u00bfpara qu\u00e9 sirve el comando git clone? Sirve para recuperar un repositorio completo desde una ubicaci\u00f3n alojada a trav\u00e9s de url. 8. En Git, \u00bfpara qu\u00e9 sirve el comando git status? Sirve para mostrar archivos modificados en el directorio de trabajo, preparado para su pr\u00f3xima ejecuci\u00f3n. 9. En Git, \u00bfpara qu\u00e9 sirve el comando git add? Sirve para agregar archivos para la pr\u00f3xima ejecuci\u00f3n. 10. En Git, \u00bfpara qu\u00e9 sirve el comando git commit? Sirve para confirmar su contenido en etapas como una nueva instant\u00e1nea de ejecuci\u00f3n. 11. En Git, \u00bfpara qu\u00e9 sirve el comando git log? Sirve para mostrar el historial de ejecuciones para la rama actualmente activa. 12. En Git, \u00bfpara qu\u00e9 sirve el comando git reset HEAD nombrearchivo? Sirve para mover el HEAD actual al compromiso especificado 13. En Git, \u00bfpara qu\u00e9 sirve el comando git checkout -- nombrearchivo? Sirve para deshacer cambios en un archivo concreto. 15. En Git, \u00bfpara qu\u00e9 sirve el comando git branch? Sirve para enumerar las ramas, aparecer\u00e1 un * junto a la rama actualmente activa. 16. En Git, \u00bfpara qu\u00e9 sirve el comando git checkout? Sirve para cambiar a otra rama y comprobarla en su directorio de trabajo. 17. En Git, \u00bfpara qu\u00e9 sirve el comando git merge? Sirve para fusionar una rama remota en su rama actual para actualizarla. 18. En Git, explica c\u00f3mo funciona la fusi\u00f3n (merge) de tipo fast-forward. Sirve para acelerar el flujo de trabajo en el proceso de proyecto, pudiendo cambiar el HEAD del sistema. 19. En Git, explica c\u00f3mo funciona la fusi\u00f3n (merge) de tipo 3-way. Git compara el ancestro com\u00fan con cada una de las confirmaciones de punta, la de rama master y la de rama de funciones. Git identifica estas tres confirmaciones mediante instant\u00e1neas.","title":"**Control de versiones**"},{"location":"Control%20de%20versiones/#control-de-versiones","text":"1. Adem\u00e1s de Git, \u00bfque otros sistemas de control de versiones existen? Existen otros sistemas como por ejemplo CVS, Subversion y Mercurial que son los m\u00e1s conocidos aparte de Git. 2. En Git, \u00bfqu\u00e9 tres \u00e1reas existen? Las \u00e1reas que existen son: working directory, stage area y repository. 5. En Git, \u00bfpara qu\u00e9 sirve el comando git config? Sirve para configurar la informaci\u00f3n del usuario utilizada en todos los repositorios locales. 6. En Git, \u00bfpara qu\u00e9 sirve el comando git init? Sirve para inicializar un directorio existente como un repositorio de git. 7. En Git, \u00bfpara qu\u00e9 sirve el comando git clone? Sirve para recuperar un repositorio completo desde una ubicaci\u00f3n alojada a trav\u00e9s de url. 8. En Git, \u00bfpara qu\u00e9 sirve el comando git status? Sirve para mostrar archivos modificados en el directorio de trabajo, preparado para su pr\u00f3xima ejecuci\u00f3n. 9. En Git, \u00bfpara qu\u00e9 sirve el comando git add? Sirve para agregar archivos para la pr\u00f3xima ejecuci\u00f3n. 10. En Git, \u00bfpara qu\u00e9 sirve el comando git commit? Sirve para confirmar su contenido en etapas como una nueva instant\u00e1nea de ejecuci\u00f3n. 11. En Git, \u00bfpara qu\u00e9 sirve el comando git log? Sirve para mostrar el historial de ejecuciones para la rama actualmente activa. 12. En Git, \u00bfpara qu\u00e9 sirve el comando git reset HEAD nombrearchivo? Sirve para mover el HEAD actual al compromiso especificado 13. En Git, \u00bfpara qu\u00e9 sirve el comando git checkout -- nombrearchivo? Sirve para deshacer cambios en un archivo concreto. 15. En Git, \u00bfpara qu\u00e9 sirve el comando git branch? Sirve para enumerar las ramas, aparecer\u00e1 un * junto a la rama actualmente activa. 16. En Git, \u00bfpara qu\u00e9 sirve el comando git checkout? Sirve para cambiar a otra rama y comprobarla en su directorio de trabajo. 17. En Git, \u00bfpara qu\u00e9 sirve el comando git merge? Sirve para fusionar una rama remota en su rama actual para actualizarla. 18. En Git, explica c\u00f3mo funciona la fusi\u00f3n (merge) de tipo fast-forward. Sirve para acelerar el flujo de trabajo en el proceso de proyecto, pudiendo cambiar el HEAD del sistema. 19. En Git, explica c\u00f3mo funciona la fusi\u00f3n (merge) de tipo 3-way. Git compara el ancestro com\u00fan con cada una de las confirmaciones de punta, la de rama master y la de rama de funciones. Git identifica estas tres confirmaciones mediante instant\u00e1neas.","title":"Control de versiones"},{"location":"Entornos%20de%20desarrollo%20integrado/","text":"ENTORNOS DE DESARROLLO INTEGRADO 1. Instala el editor sublime text. Saca una captura de pantalla una vez instalado. 2. Personaliza Sublime text instalando los complementos m\u00e1s importantes. Package Control instalado Emmet SideBarEnhacements HTML-CSS-JS Prettify Color Highlighter BracketHighlighter HTML5 Terminal JavaScriptNext PackageDev 3. \u00bfPara que sirve el complemento Emmet ? Haz uso de \u00e9l al escribir un archivo html de prueba. Emmet es un conjunto de complementos para editores de texto que permiten la codificaci\u00f3n y edici\u00f3n de alta velocidad en HTML, XML, XSL y otros formatos de c\u00f3digo estructurado a trav\u00e9s de la asistencia de contenido. Emmet, escribe c\u00f3digo HTML y CSS a base de abreviaciones. 4. Instala el editor Visual Studio Code. Saca una captura de pantalla una vez instalado y funcionando. 6. \u00bfQu\u00e9 paquetes b\u00e1sicos debemos instalar en Ubuntu para desarrollar en Java? Debemos instalar un JDK (Java Development Kit), ya sea el oficial de Oracle u Open JDK. 7. Instala el entorno integrado Netbeans. Saca una captura de pantalla una vez instalado y funcionando.","title":"ENTORNOS DE DESARROLLO INTEGRADO"},{"location":"Entornos%20de%20desarrollo%20integrado/#entornos-de-desarrollo-integrado","text":"","title":"ENTORNOS DE DESARROLLO INTEGRADO"},{"location":"Entornos%20de%20desarrollo%20integrado/#1-instala-el-editor-sublime-text-saca-una-captura-de-pantalla-una-vez-instalado","text":"","title":"1. Instala el editor sublime text. Saca una captura de pantalla una vez instalado."},{"location":"Entornos%20de%20desarrollo%20integrado/#2-personaliza-sublime-text-instalando-los-complementos-mas-importantes","text":"Package Control instalado Emmet SideBarEnhacements HTML-CSS-JS Prettify Color Highlighter BracketHighlighter HTML5 Terminal JavaScriptNext PackageDev","title":"2. Personaliza Sublime text instalando los complementos m\u00e1s importantes."},{"location":"Entornos%20de%20desarrollo%20integrado/#3-para-que-sirve-el-complemento-emmet-haz-uso-de-el-al-escribir-un-archivo-html-de-prueba","text":"Emmet es un conjunto de complementos para editores de texto que permiten la codificaci\u00f3n y edici\u00f3n de alta velocidad en HTML, XML, XSL y otros formatos de c\u00f3digo estructurado a trav\u00e9s de la asistencia de contenido. Emmet, escribe c\u00f3digo HTML y CSS a base de abreviaciones.","title":"3. \u00bfPara que sirve el complemento Emmet? Haz uso de \u00e9l al escribir un archivo html de prueba."},{"location":"Entornos%20de%20desarrollo%20integrado/#4-instala-el-editor-visual-studio-code-saca-una-captura-de-pantalla-una-vez-instalado-y-funcionando","text":"","title":"4. Instala el editor Visual Studio Code. Saca una captura de pantalla una vez instalado y funcionando."},{"location":"Entornos%20de%20desarrollo%20integrado/#6-que-paquetes-basicos-debemos-instalar-en-ubuntu-para-desarrollar-en-java","text":"Debemos instalar un JDK (Java Development Kit), ya sea el oficial de Oracle u Open JDK.","title":"6. \u00bfQu\u00e9 paquetes b\u00e1sicos debemos instalar en Ubuntu para desarrollar en Java?"},{"location":"Entornos%20de%20desarrollo%20integrado/#7-instala-el-entorno-integrado-netbeans-saca-una-captura-de-pantalla-una-vez-instalado-y-funcionando","text":"","title":"7. Instala el entorno integrado Netbeans. Saca una captura de pantalla una vez instalado y funcionando."},{"location":"Herramientas%20de%20desarrollo/","text":"Herramientas de desarrollo Para cada uno de los lenguajes anteriores, indica el proceso realizado para conseguir ejecutar el c\u00f3digo: bash: interpretaci\u00f3n\u00bfcompilaci\u00f3n o interpretaci\u00f3n? python: interpretaci\u00f3n php: interpretaci\u00f3n javascript: interpretaci\u00f3n c: compilaci\u00f3n c++: compilaci\u00f3n java: compilaci\u00f3n ruby: interpretaci\u00f3n go: compilaci\u00f3n rust: compilaci\u00f3n lisp: compilaci\u00f3n nasm: compilaci\u00f3n Para cada uno de los lenguajes anteriores, indica el nombre del compilador o int\u00e9rprete utilizado en GNU/Linux. bash: SHELL python: GNU Readline php: Software libre javascript: Software libre c: gcc c++: cc java: javac ruby: IRB go: go build rust: rustc lisp: ABCL nasm: ensamblador Investiga y averigua qu\u00e9 extensi\u00f3n tienen los archivos de c\u00f3digo fuente de los siguientes lenguajes: bash: .sh python: .py php: .php javascript: .js c: .c c++: .cc java: .java ruby: .ruby go: .go rust: .rs lisp: .lisp nasm: .asm \u00bfQu\u00e9 extensi\u00f3n tienen los archivos de c\u00f3digo objeto? Los archivos de objeto ( cuya extensi\u00f3n es .obj) son archivos intermedios generados por el compilador antes de crear un ejecutable. El archivo de objeto consiste de una tabla de s\u00edmbolos y el c\u00f3digo C compilado en c\u00f3digo de m\u00e1quina. La tabla de s\u00edmbolos contiene una lista de funciones y la direcci\u00f3n del archivo objeto en donde se localiza el c\u00f3digo para esa funci\u00f3n en particular. Todos los compiladores generan los archivos objeto de diferente manera. El ligador es responsable de manipular las llamadas a funciones que se encuentran fuera del archivo de c\u00f3digo C que ha sido compilado; busca las referencias a esas funciones en las tablas de s\u00edmbolos de todos los archivos objeto que est\u00e1n disponibles. Si las referencias son encontradas, se ligan con el c\u00f3digo, si no, se genera el error Undefined Symbol. Define qu\u00e9 se entiende por biblioteca o librer\u00eda y los tipos que existen. Una biblioteca es un conjunto de archivos que se utiliza para desarrollar software. Suele estar compuesta de c\u00f3digo y datos, y su fin es ser utilizada por otros programas de forma totalmente aut\u00f3noma. Simple y llanamente, es un archivo importable. Hay dos tipos de bibliotecas en programaci\u00f3n, las din\u00e1micas y las est\u00e1ticas. Las est\u00e1ticas se graban en un programa como ejecutables y sirven exclusivamente para eso, luego se puede borrar sin problemas. Las din\u00e1micas no se copian en el programa al compilaralas, las subrutinas son cargadas en tiempo de ejecuci\u00f3n, en vez de enlazarse en tiempo de compilaci\u00f3n. \u00bfQu\u00e9 tipo es el m\u00e1s utilizado actualmente? \u00bfPor qu\u00e9? Las bibliotecas din\u00e1micas, porque utilizan recursos independientes al ejecutable que las llama. Es decir, no es copiada al programa durante el proceso de compilaci\u00f3n. Busca informaci\u00f3n y explica las ventajas y desventajas de usar bibliotecas est\u00e1ticas. Ventajas: Las bibliotecas est\u00e1ticas resisten la vulnerabilidad porque viven dentro del archivo ejecutable. La velocidad en tiempo de ejecuci\u00f3n se produce m\u00e1s r\u00e1pido porque su c\u00f3digo objeto est\u00e1 en el archivo ejecutable. Por lo tanto, las llamadas realizadas a las funciones se ejecutan m\u00e1s r\u00e1pido. Recuerde, la biblioteca din\u00e1mica vive fuera del ejecutable, por lo que las llamadas se realizan desde el exterior del ejecutable. Desventajas: Los cambios realizados en los archivos y el programa requieren volver a enlazar y recompilar. El tama\u00f1o del archivo es mucho mayor. Busca informaci\u00f3n y explica las ventajas y desventajas de usar bibliotecas din\u00e1micas. Ventajas. Solo necesita una copia en tiempo de ejecuci\u00f3n. Depende de que la aplicaci\u00f3n y la biblioteca est\u00e9n estrechamente disponibles entre s\u00ed. Varias aplicaciones en ejecuci\u00f3n utilizan la misma biblioteca sin necesidad de que cada archivo tenga su propia copia. Est\u00e1n vinculadas en tiempo de ejecuci\u00f3n. No requiere recompilaci\u00f3n y volver a enlazar cuando el programador realiza un cambio. Desventajas: Si la biblioteca din\u00e1mica se da\u00f1a el archivo ejecutable puede no funcionar porque vive fuera del ejecutable y es vulnerable a la rotura. Contienen archivos m\u00e1s peque\u00f1os.","title":"Herramientas de desarrollo"},{"location":"Herramientas%20de%20desarrollo/#herramientas-de-desarrollo","text":"Para cada uno de los lenguajes anteriores, indica el proceso realizado para conseguir ejecutar el c\u00f3digo: bash: interpretaci\u00f3n\u00bfcompilaci\u00f3n o interpretaci\u00f3n? python: interpretaci\u00f3n php: interpretaci\u00f3n javascript: interpretaci\u00f3n c: compilaci\u00f3n c++: compilaci\u00f3n java: compilaci\u00f3n ruby: interpretaci\u00f3n go: compilaci\u00f3n rust: compilaci\u00f3n lisp: compilaci\u00f3n nasm: compilaci\u00f3n Para cada uno de los lenguajes anteriores, indica el nombre del compilador o int\u00e9rprete utilizado en GNU/Linux. bash: SHELL python: GNU Readline php: Software libre javascript: Software libre c: gcc c++: cc java: javac ruby: IRB go: go build rust: rustc lisp: ABCL nasm: ensamblador Investiga y averigua qu\u00e9 extensi\u00f3n tienen los archivos de c\u00f3digo fuente de los siguientes lenguajes: bash: .sh python: .py php: .php javascript: .js c: .c c++: .cc java: .java ruby: .ruby go: .go rust: .rs lisp: .lisp nasm: .asm \u00bfQu\u00e9 extensi\u00f3n tienen los archivos de c\u00f3digo objeto? Los archivos de objeto ( cuya extensi\u00f3n es .obj) son archivos intermedios generados por el compilador antes de crear un ejecutable. El archivo de objeto consiste de una tabla de s\u00edmbolos y el c\u00f3digo C compilado en c\u00f3digo de m\u00e1quina. La tabla de s\u00edmbolos contiene una lista de funciones y la direcci\u00f3n del archivo objeto en donde se localiza el c\u00f3digo para esa funci\u00f3n en particular. Todos los compiladores generan los archivos objeto de diferente manera. El ligador es responsable de manipular las llamadas a funciones que se encuentran fuera del archivo de c\u00f3digo C que ha sido compilado; busca las referencias a esas funciones en las tablas de s\u00edmbolos de todos los archivos objeto que est\u00e1n disponibles. Si las referencias son encontradas, se ligan con el c\u00f3digo, si no, se genera el error Undefined Symbol. Define qu\u00e9 se entiende por biblioteca o librer\u00eda y los tipos que existen. Una biblioteca es un conjunto de archivos que se utiliza para desarrollar software. Suele estar compuesta de c\u00f3digo y datos, y su fin es ser utilizada por otros programas de forma totalmente aut\u00f3noma. Simple y llanamente, es un archivo importable. Hay dos tipos de bibliotecas en programaci\u00f3n, las din\u00e1micas y las est\u00e1ticas. Las est\u00e1ticas se graban en un programa como ejecutables y sirven exclusivamente para eso, luego se puede borrar sin problemas. Las din\u00e1micas no se copian en el programa al compilaralas, las subrutinas son cargadas en tiempo de ejecuci\u00f3n, en vez de enlazarse en tiempo de compilaci\u00f3n. \u00bfQu\u00e9 tipo es el m\u00e1s utilizado actualmente? \u00bfPor qu\u00e9? Las bibliotecas din\u00e1micas, porque utilizan recursos independientes al ejecutable que las llama. Es decir, no es copiada al programa durante el proceso de compilaci\u00f3n. Busca informaci\u00f3n y explica las ventajas y desventajas de usar bibliotecas est\u00e1ticas. Ventajas: Las bibliotecas est\u00e1ticas resisten la vulnerabilidad porque viven dentro del archivo ejecutable. La velocidad en tiempo de ejecuci\u00f3n se produce m\u00e1s r\u00e1pido porque su c\u00f3digo objeto est\u00e1 en el archivo ejecutable. Por lo tanto, las llamadas realizadas a las funciones se ejecutan m\u00e1s r\u00e1pido. Recuerde, la biblioteca din\u00e1mica vive fuera del ejecutable, por lo que las llamadas se realizan desde el exterior del ejecutable. Desventajas: Los cambios realizados en los archivos y el programa requieren volver a enlazar y recompilar. El tama\u00f1o del archivo es mucho mayor. Busca informaci\u00f3n y explica las ventajas y desventajas de usar bibliotecas din\u00e1micas. Ventajas. Solo necesita una copia en tiempo de ejecuci\u00f3n. Depende de que la aplicaci\u00f3n y la biblioteca est\u00e9n estrechamente disponibles entre s\u00ed. Varias aplicaciones en ejecuci\u00f3n utilizan la misma biblioteca sin necesidad de que cada archivo tenga su propia copia. Est\u00e1n vinculadas en tiempo de ejecuci\u00f3n. No requiere recompilaci\u00f3n y volver a enlazar cuando el programador realiza un cambio. Desventajas: Si la biblioteca din\u00e1mica se da\u00f1a el archivo ejecutable puede no funcionar porque vive fuera del ejecutable y es vulnerable a la rotura. Contienen archivos m\u00e1s peque\u00f1os.","title":"Herramientas de desarrollo"},{"location":"Lenguajes%20de%20programaci%C3%B3n/","text":"Lenguajes de programaci\u00f3n \u00bfQu\u00e9 diferencia existe entre los lenguajes declarativos y los imperativos?. Nombra al menos 2 de cada tipo. La programaci\u00f3n imperativa, como su nombre indica, es un tipo de paradigma de programaci\u00f3n que describe c\u00f3mo se ejecuta el programa. Los desarrolladores est\u00e1n m\u00e1s preocupados por c\u00f3mo obtener una respuesta paso a paso. Comprende la secuencia de imperativos de mando. En esto, el orden de ejecuci\u00f3n es muy importante y utiliza datos tanto mutables como inmutables. Los lenguajes de programaci\u00f3n Fortran, Java , C , C++ son ejemplos de programaci\u00f3n imperativa. La programaci\u00f3n declarativa, como su nombre indica, es un tipo de paradigma de programaci\u00f3n que describe qu\u00e9 programas se ejecutar\u00e1n. Los desarrolladores est\u00e1n m\u00e1s preocupados por la respuesta que se recibe. Declara qu\u00e9 tipo de resultados queremos y deja el lenguaje de programaci\u00f3n a un lado, enfoc\u00e1ndose simplemente en descubrir c\u00f3mo producirlos. En palabras simples, se centra principalmente en el resultado final. Expresa la l\u00f3gica de la computaci\u00f3n. Miranda, Erlang, Haskell, Prolog son algunos ejemplos populares de programaci\u00f3n declarativa. \u00bfExplica qu\u00e9 es compilar? \u00bfExplica qu\u00e9 es interpretar? Compilar es el proceso de transformar un programa inform\u00e1tico escrito en un lenguaje en un programa equivalente en otro formato. Al programa que se encarga de compilar se le llama compilador. A veces, a esta tarea se le llama \"ensamblar\" o \"construir\", lo que suele implicar otros procesos adicionales. Un lenguaje interpretado es un lenguaje para el que la mayor\u00eda de sus implementaciones ejecuta las instrucciones directamente, sin una previa compilaci\u00f3n del programa a instrucciones en lenguaje de m\u00e1quina. El int\u00e9rprete ejecuta el programa directamente, traduciendo cada sentencia en una secuencia de una o m\u00e1s subrutinas ya compiladas en c\u00f3digo m\u00e1quina. Ventajas de los lenguajes compilados. Los programas compilados en c\u00f3digo nativo en tiempo de compilaci\u00f3n tienden a ser m\u00e1s r\u00e1pidos que los traducidos en tiempo de ejecuci\u00f3n debido a la sobrecarga del proceso de traducci\u00f3n. Sin embargo, las tecnolog\u00edas m\u00e1s nuevas, como la compilaci\u00f3n justo a tiempo y las mejoras generales en el proceso de traducci\u00f3n, est\u00e1n comenzando a reducir esta brecha. Las soluciones mixtas que utilizan bytecode tienden a una eficiencia intermedia. Los lenguajes de programaci\u00f3n de alto nivel generalmente se compilan, especialmente cuando la eficiencia es la principal preocupaci\u00f3n, en lugar del soporte multiplataforma. Para tales lenguajes, hay m\u00e1s correspondencias uno a uno entre el c\u00f3digo programado y las operaciones de hardware realizadas por el c\u00f3digo de m\u00e1quina , lo que facilita a los programadores el control del uso de la unidad central de procesamiento (CPU) y la memoria con gran detalle. Con algo de esfuerzo, siempre es posible escribir compiladores incluso para lenguajes interpretados tradicionalmente . Por ejemplo, Common lisp se puede compilar en c\u00f3digo de bytes Java (luego interpretado por la m\u00e1quina virtual Java, c\u00f3digo C (luego compilado en c\u00f3digo de m\u00e1quina nativo) o directamente en c\u00f3digo nativo. Los lenguajes de programaci\u00f3n que admiten m\u00faltiples objetivos de compilaci\u00f3n brindan a los desarrolladores m\u00e1s control para elegir la velocidad de ejecuci\u00f3n o la compatibilidad entre plataformas. Ventajas de los lenguajes interpretados La principal ventaja de un lenguaje interpretado es que es independiente de la m\u00e1quina y del sistema operativo ya que no contiene instrucciones propias de un procesador sino que contiene llamadas a funciones que el interprete deber\u00e1 reconocer. Basta que exista un interprete de un lenguaje para dicho sistema y todos los programas escrito en ese lenguaje funcionaran. Adem\u00e1s un lenguaje interpretado permite modificar en tiempo de ejecuci\u00f3n el c\u00f3digo que se est\u00e1 ejecutando as\u00ed como a\u00f1adirle nuevo, algo que resulta id\u00f3neo cuando queremos hacer peque\u00f1as modificaciones en una aplicaci\u00f3n y no queremos tener que recompilarla toda cada vez. Nombra 2 lenguajes compilados y otros 2 interpretados. Compilados: Java, C++ Interpretados: Python, PHP. \u00bfPuede considerarse c\u00f3digo objeto el bytecode generado en Java tras la compilaci\u00f3n? Explica la respuesta. El bytecode o c\u00f3digo intermedio es un lenguaje intermedio m\u00e1s abstracto que el lenguaje m\u00e1quina. Habitualmente, es tratado como un archivo binario que contiene un programa ejecutable similar a un m\u00f3dulo objeto, que es un archivo binario producido por el compilador cuyo contenido es el c\u00f3digo objeto o c\u00f3digo m\u00e1quina. S\u00ed es un c\u00f3digo objeto porque resulta de la compilaci\u00f3n del c\u00f3digo fuente Pon un ejemplo de lenguaje de los siguientes tipos: Bajo nivel: C\u00f3digo m\u00e1quina Nivel medio: C Alto nivel: Java \u00bfQu\u00e9 paradigma de programaci\u00f3n siguen los siguientes lenguajes? C: Lenguaje de prop\u00f3sito general. C++: Multiparadigma, programaci\u00f3n gen\u00e9rica y orientada a objetos de procedimiento SQL: Multiparadigma Java: Paradigma declarativo Javascript: Multiparadigma Lisp: Multiparadigma Prolog: Lenguajes l\u00f3gicos y declarativos Explica qu\u00e9 criterios pueden seguirse a la hora de elegir un lenguaje de programaci\u00f3n para el desarrollo software. Aplicaci\u00f3n . Si te gusta el desarrollo de juegos, aplicaciones m\u00f3viles o sitios web, los lenguajes que necesitas aprender son totalmente diferentes, algo muy obvio, puesto que los lenguajes de programaci\u00f3n se crean con un prop\u00f3sito en espec\u00edfico. Salario. Existen varios lenguajes por los cuales pagan muy buenos salarios anuales. Por desgracias, por algunos no sucede lo mismo. Sera decisi\u00f3n tuya ver por cual te decantas y que disfrutes trabajar con ese. Geograf\u00eda. Este el tercer criterio que se debe tomar en cuenta al momento de elegir un lenguaje de programaci\u00f3n, ayuda a determinar que tantas personas utilizan ese lenguaje y que en alg\u00fan momento te pueden ayudar, o puedes tomarlo tambi\u00e9n como una oportunidad para destacar en un lenguaje que no sea com\u00fan en esa regi\u00f3n. Popularidad . Este aspecto resulta importantes cuando quieres trabajar como Freelancer. Un lenguaje de programaci\u00f3n tiene que ser suficientemente popular para generar nuevo proyectos en los que puedas trabajar.","title":"*Lenguajes de programaci\u00f3n*"},{"location":"Lenguajes%20de%20programaci%C3%B3n/#lenguajes-de-programacion","text":"\u00bfQu\u00e9 diferencia existe entre los lenguajes declarativos y los imperativos?. Nombra al menos 2 de cada tipo. La programaci\u00f3n imperativa, como su nombre indica, es un tipo de paradigma de programaci\u00f3n que describe c\u00f3mo se ejecuta el programa. Los desarrolladores est\u00e1n m\u00e1s preocupados por c\u00f3mo obtener una respuesta paso a paso. Comprende la secuencia de imperativos de mando. En esto, el orden de ejecuci\u00f3n es muy importante y utiliza datos tanto mutables como inmutables. Los lenguajes de programaci\u00f3n Fortran, Java , C , C++ son ejemplos de programaci\u00f3n imperativa. La programaci\u00f3n declarativa, como su nombre indica, es un tipo de paradigma de programaci\u00f3n que describe qu\u00e9 programas se ejecutar\u00e1n. Los desarrolladores est\u00e1n m\u00e1s preocupados por la respuesta que se recibe. Declara qu\u00e9 tipo de resultados queremos y deja el lenguaje de programaci\u00f3n a un lado, enfoc\u00e1ndose simplemente en descubrir c\u00f3mo producirlos. En palabras simples, se centra principalmente en el resultado final. Expresa la l\u00f3gica de la computaci\u00f3n. Miranda, Erlang, Haskell, Prolog son algunos ejemplos populares de programaci\u00f3n declarativa. \u00bfExplica qu\u00e9 es compilar? \u00bfExplica qu\u00e9 es interpretar? Compilar es el proceso de transformar un programa inform\u00e1tico escrito en un lenguaje en un programa equivalente en otro formato. Al programa que se encarga de compilar se le llama compilador. A veces, a esta tarea se le llama \"ensamblar\" o \"construir\", lo que suele implicar otros procesos adicionales. Un lenguaje interpretado es un lenguaje para el que la mayor\u00eda de sus implementaciones ejecuta las instrucciones directamente, sin una previa compilaci\u00f3n del programa a instrucciones en lenguaje de m\u00e1quina. El int\u00e9rprete ejecuta el programa directamente, traduciendo cada sentencia en una secuencia de una o m\u00e1s subrutinas ya compiladas en c\u00f3digo m\u00e1quina. Ventajas de los lenguajes compilados. Los programas compilados en c\u00f3digo nativo en tiempo de compilaci\u00f3n tienden a ser m\u00e1s r\u00e1pidos que los traducidos en tiempo de ejecuci\u00f3n debido a la sobrecarga del proceso de traducci\u00f3n. Sin embargo, las tecnolog\u00edas m\u00e1s nuevas, como la compilaci\u00f3n justo a tiempo y las mejoras generales en el proceso de traducci\u00f3n, est\u00e1n comenzando a reducir esta brecha. Las soluciones mixtas que utilizan bytecode tienden a una eficiencia intermedia. Los lenguajes de programaci\u00f3n de alto nivel generalmente se compilan, especialmente cuando la eficiencia es la principal preocupaci\u00f3n, en lugar del soporte multiplataforma. Para tales lenguajes, hay m\u00e1s correspondencias uno a uno entre el c\u00f3digo programado y las operaciones de hardware realizadas por el c\u00f3digo de m\u00e1quina , lo que facilita a los programadores el control del uso de la unidad central de procesamiento (CPU) y la memoria con gran detalle. Con algo de esfuerzo, siempre es posible escribir compiladores incluso para lenguajes interpretados tradicionalmente . Por ejemplo, Common lisp se puede compilar en c\u00f3digo de bytes Java (luego interpretado por la m\u00e1quina virtual Java, c\u00f3digo C (luego compilado en c\u00f3digo de m\u00e1quina nativo) o directamente en c\u00f3digo nativo. Los lenguajes de programaci\u00f3n que admiten m\u00faltiples objetivos de compilaci\u00f3n brindan a los desarrolladores m\u00e1s control para elegir la velocidad de ejecuci\u00f3n o la compatibilidad entre plataformas. Ventajas de los lenguajes interpretados La principal ventaja de un lenguaje interpretado es que es independiente de la m\u00e1quina y del sistema operativo ya que no contiene instrucciones propias de un procesador sino que contiene llamadas a funciones que el interprete deber\u00e1 reconocer. Basta que exista un interprete de un lenguaje para dicho sistema y todos los programas escrito en ese lenguaje funcionaran. Adem\u00e1s un lenguaje interpretado permite modificar en tiempo de ejecuci\u00f3n el c\u00f3digo que se est\u00e1 ejecutando as\u00ed como a\u00f1adirle nuevo, algo que resulta id\u00f3neo cuando queremos hacer peque\u00f1as modificaciones en una aplicaci\u00f3n y no queremos tener que recompilarla toda cada vez. Nombra 2 lenguajes compilados y otros 2 interpretados. Compilados: Java, C++ Interpretados: Python, PHP. \u00bfPuede considerarse c\u00f3digo objeto el bytecode generado en Java tras la compilaci\u00f3n? Explica la respuesta. El bytecode o c\u00f3digo intermedio es un lenguaje intermedio m\u00e1s abstracto que el lenguaje m\u00e1quina. Habitualmente, es tratado como un archivo binario que contiene un programa ejecutable similar a un m\u00f3dulo objeto, que es un archivo binario producido por el compilador cuyo contenido es el c\u00f3digo objeto o c\u00f3digo m\u00e1quina. S\u00ed es un c\u00f3digo objeto porque resulta de la compilaci\u00f3n del c\u00f3digo fuente Pon un ejemplo de lenguaje de los siguientes tipos: Bajo nivel: C\u00f3digo m\u00e1quina Nivel medio: C Alto nivel: Java \u00bfQu\u00e9 paradigma de programaci\u00f3n siguen los siguientes lenguajes? C: Lenguaje de prop\u00f3sito general. C++: Multiparadigma, programaci\u00f3n gen\u00e9rica y orientada a objetos de procedimiento SQL: Multiparadigma Java: Paradigma declarativo Javascript: Multiparadigma Lisp: Multiparadigma Prolog: Lenguajes l\u00f3gicos y declarativos Explica qu\u00e9 criterios pueden seguirse a la hora de elegir un lenguaje de programaci\u00f3n para el desarrollo software. Aplicaci\u00f3n . Si te gusta el desarrollo de juegos, aplicaciones m\u00f3viles o sitios web, los lenguajes que necesitas aprender son totalmente diferentes, algo muy obvio, puesto que los lenguajes de programaci\u00f3n se crean con un prop\u00f3sito en espec\u00edfico. Salario. Existen varios lenguajes por los cuales pagan muy buenos salarios anuales. Por desgracias, por algunos no sucede lo mismo. Sera decisi\u00f3n tuya ver por cual te decantas y que disfrutes trabajar con ese. Geograf\u00eda. Este el tercer criterio que se debe tomar en cuenta al momento de elegir un lenguaje de programaci\u00f3n, ayuda a determinar que tantas personas utilizan ese lenguaje y que en alg\u00fan momento te pueden ayudar, o puedes tomarlo tambi\u00e9n como una oportunidad para destacar en un lenguaje que no sea com\u00fan en esa regi\u00f3n. Popularidad . Este aspecto resulta importantes cuando quieres trabajar como Freelancer. Un lenguaje de programaci\u00f3n tiene que ser suficientemente popular para generar nuevo proyectos en los que puedas trabajar.","title":"Lenguajes de programaci\u00f3n"}]}